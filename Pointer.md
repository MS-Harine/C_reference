# 포인터의 모든 내용

[TOC]

## 변수

 변수란, **변할 수 있는 수**를 뜻한다. 수학적 의미의 변수와 C언어에서의 변수는 거의 비슷하다. 임시적으로 수를 저장할 수 있는 공간으로, 그 공간 내부에 있는 수는 변할 수 있다. 선언은 다음과 같이 한다.

``` c
<Type> name ;	// Grammer
int var;
float var;
short var;
```

변수를 선언하면, 컴퓨터 내부적으로는 공간을 할당한다. 이 공간은 **주소, 값**을 가지고 있으며, 이 공간에 접근하기 위한 **이름**도 따로 저장한다. 즉, 변수 선언으로 세 가지 정보를 얻게 된다.

* 이름
* 주소
* 값

### 이름

 변수를 선언하고, 컴퓨터 내부적으로 할당 된 공간에 붙은 이름은 한 번 할당되면 변경할 수 없다. 이름을 재할당 하기 위해서는 새로운 변수를 선언해야 한다. 이름을 할당하는 방법은 변수를 선언하면서 동시에 할당하게 된다.

### 주소

 변수가 선언 된 공간에는 컴퓨터 내부의 물리적인 주소가 존재한다. 이 주소는 임의적으로 변경할 수 없으며, 운영체제에 의해 관리된다. 보통 16진수로 표현하며, `0x3F12A6` 등과 같이 표현된다. (`0x` 는 16진수를 의미한다.) 변수에게 할당 된 공간의 주소값을 알기 위해서는 `&` 기호를 사용한다. 또한, 주소를 출력하기 위해서는 `%p` 서식문자를 사용한다.

```c
int var;
printf("%p", &var);		// 0x000123
```

보편적으로 변수에 접근하기 위해서는 이름을 사용하지만, 주소 또한 접근에 사용될 수 있다. 이는 주소가 물리적이고 직접적인 공간을 의미하기 때문이다. 주소로 변수에 접근하는 방법은 [여기](#포인터)에서 소개한다.

### 값

 변수에 저장되는 값은 언제든지 변경될 수 있다. 처음 변수가 할당되면, 그 공간에는 기존에 할당되어 있던 값이 남아있다. 이 값은 '쓰레기값'으로 불리며, 현재 사용자에게 아무런 의미가 없다. 변수에 값을 처음으로 할당하는, 즉 쓰레기값에서 의미 있는 값으로 처음 값을 넣는 연산을 **초기화(Initialize)** 한다고 한다. 변수에 값을 지정하기 위해서는 `=` 기호를 사용한다.

```c
int var = 3;	// Declaration and initialization
var = 5;	// Not initialization
```



## 포인터

 C언어에서 말하는 포인터란, 포인터 변수를 줄인 것이며 **변수의 주소를 저장한 변수**를 말한다. 다시 말하면, 변수의 '값'으로 다른 변수의 주소를 가지고 있는 것이다. 

### 포인터 변수의 선언

 포인터 변수 역시 변수이기 때문에 다른 변수의 선언과 같이 `<Type> name;` 형식으로 선언한다. 다만, 다른 변수의 선언과 다른 점이 있다면 Type의 형태가 다른 자료형에 `*`이 붙은 형태라는 것이다.

|     Grammer     |    Type    |  Name  |
| :-------------: | :--------: | :----: |
|   `int *var;`   |  `int *`   | `var`  |
|  `float *num;`  | `float *`  | `num`  |
| `double *temp;` | `double *` | `temp` |

* `int *var;` 는 int형 변수의 주소를 저장하는 변수이다.
* `float *var;` 는 float형 변수의 주소를 저장하는 변수이다.
* `double *var;` 은 double형 변수의 주소를 저장하는 변수이다.

> <Type> * name; 형식의 변수 선언은 <Type>형 변수의 주소를 저장하는 변수이다.

### 포인터 변수의 값 할당

 포인터 변수는 변수의 주소를 저장하기 때문에 일반 변수처럼 `int var = 3;` 처럼 맘편하게 값을 할당할 수 없다. 어떤 변수의 주소값을 할당하거나, 직접 주소값을 할당해야 한다. 변수의 주소값에 접근할 때는 `&` 기호를 사용하니, 다음과 같이 변수에 값을 할당할 수 있다.

```c
int var;
int *p = &var;
int *p2 = 0x000123;
```

### 할당된 주소값에 접근하기

 포인터 변수에 저장된 값은 일종의 주소값이다. 이 주소값에 접근하기 위해서는 `*` 기호를 사용한다. 주소값에 접근한다는 뜻은, 포인터 변수에 저장되어 있는 값의 주소에 있는 값에 접근한다는 뜻이다.

``` c
int var = 3;	// 주소값이 0x100이라고 가정하자.
int *p = &var;	// p에 var의 주소값(0x100)을 저장한다.
printf("%p", p);	// p를 출력하기 위해서는 주소값을 출력하는 것이기 때문에 %p를 사용한다.
			// 0x100이 출력된다.
printf("%d", *p);	// p에 저장되어 있는 주소값으로 가기 때문에 0x100번지의 값을 출력한다.
			// 3이 출력된다.
```

단순히 출력 말고도, 값을 변환할 수도 있다.

```c
int var = 3;
int *p = &var;
printf("%d", var);	// 3
*p = 5;
printf("%d", var);	// 5
```

또한, 포인터는 주소값을 저장하는 것이기 때문에 변수를 가리키는 화살표 같은 역할로 생각할 수도 있다.

```c
int var1 = 3;
int var2 = 5;
int *p = &var1;
printf("%d", *p);	// 3
p = &var2;
printf("%d", *p);	// 5
```



## 함수

### 함수에서 값 변환하기

 함수는 자신이 호출될 때 몇 가지 값을 같이 받을 수 있다. 이를 인자, 혹은 파라미터(Parameter)라고 한다. 이 때, 파라미터로 값을 넣으면 C언어에서는 값을 복사하기 때문에 함수 안에서 값을 변경해도, 함수가 끝나면 값이 변경되어 있지 않다. 아래는 그 예시이다.

```c
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    printf("In swap func() : %d, %d\n", a, b);
}

int main() {
    int num1 = 3;
    int num2 = 5;
    
    printf("Before swap : %d, %d\n", num1, num2);
    swap(num1, num2);
    printf("After swap : %d, %d\n", num1, num2);
    
    return 0;
}
```

위 프로그램의 실행 결과는 다음과 같다.

```bash
Before swap : 3, 5
In swap func() : 5, 3
After swap : 3, 5
```

값이 변경되지 않은 이유는, swap 함수 내부에서는 값이 복사되어 (새로운 변수가 선언되고, 값을 할당하여) 변경이 되었지만, 함수가 끝나고 나서 다시 main 함수로 돌아왔을 때는 num1, num2에 있는 변수는 손을 대지 않은 것이기 때문에 변경되지 않는다.

 하지만, 포인터를 이용하면 함수 내에서도 값을 변경할 수 있다. 함수에게 주소값을 넘겨주고, 함수 내부에서는 주소값을 이용하여 원래 변수의 위치에 접근하여 그 값을 직접 바꾸는 것이다. 아래는 그 예시이다.

```c
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int num1 = 3;
    int num2 = 5;
    
    printf("Before swap : %d, %d\n", num1, num2);
    swap(&num1, &num2);
    printf("After swap : %d, %d\n", num1, num2);
    
    return 0;
}
```

위 프로그램의 실행 결과는 다음과 같다.

```bash
Before swap : 3, 5
After swap : 5, 3
```

`swap(&num1, &num2);` 부분에 주의해야 한다. 함수의 파라미터가 포인터 변수로 선언되었기 때문에 주소값을 넘겨주어야 한다. 따라서 `&` 기호를 사용해야 하고, 함수 내부에서는 `*` 기호를 통해 함수의 주소에 접근하여 그 값을 직접 변경하여야 한다.

 첫 번째와 같이 값을 복사하여 넘기는 경우를 **Call-by-value**라고 하며, 두 번째 경우와 같이 주소값을 이용해 값을 넘기는 경우를 **Call-by-reference**라고 한다.



## 배열과 포인터

 배열과 포인터가 다른 것이라고 생각하는 분들이 많다. 물론 프로그래밍적으로 다른 것은 맞으나, 근본적으로는 같다.

### 배열과 주소

 배열은 여러 가지의 연관된 정보를 연달아 저장할 수 있게 만들어 놓은 타입이다. 이를 주소와 연관시켜보면 포인터와 크게 다름이 없음을 알 수 있다. 이번 내용에서의 코드는 모두 연결되어 있다고 가정한다.

```c
int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
```

이렇게 배열을 선언하면, 컴퓨터 내부에서는 배열에 크기에 맞게 공간을 할당하기 시작한다. 컴퓨터에서 int를 4byte로 처리한다고 가정하면, 컴퓨터는 4byte * 10개 = 40byte의 공간을 arr에게 할당한다. 하지만, 다른 변수들의 선언과 가장 큰 차이점이 하나 있다. 그것은 바로 **할당된 공간들이 모두 연달아 있다**는 점이다. 풀어 말하면, 다음과 같다.

```c
for (int i = 0; i < 10; i++)
    printf("%p ", &arr[i]);
```

이 코드는 배열의 원소 하나하나를 보면서 그 원소들의 주소를 출력하는 코드이다. 배열의 처음, 즉 arr[0]번의 주소를 0x100이라고 가정하면, 다음과 같은 결과가 나온다.

```bash
0x100 0x104 0x108 0x10C 0x110 0x114 0x118 0x11C 0x120 0x124
256   260   264   268   272   276   280   284   288   292
```

위 숫자는 16진수로 주소를 나타낸 것이고, 아래는 이를 10진수로 변환한 숫자이다. 모두 연달아 4byte씩 차이난다. 이는 정말 물리적으로도 바로 옆 자리에 할당된 것으로 이해할 수 있다.

 한 가지를 더 살펴봐야 한다. 배열의 이름을 그냥 출력해 본 적이 있는가? 배열의 이름은 그 배열의 시작 주소값을 나타낸다. 다음의 예제를 보자.

```c
printf("%p", arr);
```

이 예제 코드의 결과는 `0x100` 이다. 어디서 본 것과 많이 비슷하지 않은가? 바로 포인터 변수를 직접 출력한 것과 같다. 즉, **배열의 이름은 포인터 변수**라는 소리다. 그래서 이걸 가지고 어디에 써먹을 수 있을까?

### 포인터의 덧셈

 포인터 변수에 덧셈을 해본 적은 없을 것이다. 몇가지 예제를 살펴보자.

```c
int *a = 0x100;
float *b = 0x200;
double *c = 0x300;
printf("%p %p %p", a + 1, b + 2, c + 3);
```

이 코드의 출력이 어떻게 될지 예상해보자. 여기서 int는 4byte, float과 double은 8byte로 가정한다. 평범하게 생각해보면, 101, 202, 303이 나올 것 같다. 그러나, 답은 다음과 같다.

```bash
0x104 0x208 0x30C
```

**포인터 변수에 더하기 1을 할 때마다, 자동으로 곱하기 타입의 byte 크기가 된다.** 왜냐하면 int 변수 하나를 저장하면, 4byte를 파차지하기 때문에 포인터에 +1을 하게 되면, 다음 바이트를 가리키는 것이 아닌 다음 숫자를 가리키고 싶어 할 것이라는 의도 때문이다. 예제를 통해 이해해보자.

```c
1 int a = 3;	// 0x100번지로 가정해보자.
2 00000000 00000000 00000000 00000011
3 0x100    0x101    0x102    0x103
```

1번 줄과 같이 변수를 선언하게 되면, 실제로는 2번 줄과 같은 정보가 저장된다. 이 때 1byte가 한 주소를 차지하기 때문에 실제 주소는 3번줄과 같이 할당된다. 그렇다면, 여기에 이어서 다음 예제를 보자.

```c
4 int *p = &a;
5 int b = *(p + 1);
```

여기서 p는 0x100이다. 만약, p+1이 0x101이 된다면, b는 어떤 수가 저장이 되어 있을까? 0x101번지부터 4byte를 계산해야 하는 말도 안되는 상황이 생긴다. 분명 a는 0x100 ~ 0x103번지 까지의 수를 저장하고 있지만, b가 0x101 ~ 0x104번지까지의 수를 저장하고 있다면 a가 변경되면 b도 변경되는 웃긴 상황이 연출된다. 그렇기때문에 포인터의 덧셈을 할 때는 타입의 크기만큼 곱해서 건너 뛰는 것이다.

### 배열과 포인터의 관계

 위 두가지 정보를 종합해보면, 배열을 포인터로 접근할 수 있다는 결론이 나온다. 다음 예제를 보자.

```c
int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int *p = arr;	// arr은 배열 이름이고, 배열의 첫 번재 주소를 가리키기 때문에 &기호를 사용하지 않는다.

// 1번 반복문
for (int i = 0; i < 10; i++)
    printf("%d ", arr[i]);
printf("\n");

// 2번 반복문
for (int i = 0; i < 10; i++)
    printf("%d ", *(p + i));
```

결론은 1번 반복문과 2번 반복문의 출력은 모두 `0 1 2 3 4 5 6 7 8 9`로 같다. 즉, 배열과 포인터는 근본적으로 같은 것임을 알 수 있다. 여기서 큰 결론 하나가 나온다.

> **배열 = 포인터**

정확한 의미로 배열이 포인터는 아니다. 하지만, 배열을 포인터로 인식하고 접근할 수 있다는 점을 말하고 싶다.

 반대로의 접근도 가능하다. 다음 예제를 보자.

```c
int *arr = (int *)malloc(sizeof(int) * 10);
for (int i = 0; i < 10; i++)
    arr[i] = i;
```

분명 포인터로 선언했지만, 배열처럼 접근한다. 위 코드는 포인터로 int형 10칸의 공간을 할당받고, 거기에 값을 할당하는 코드이다. 한 가지 알아야 할 사실은 우리가 배열을 접근할 때 사용하는 대괄호 `[]` 역시 연산자이다. 이를 수식으로 풀면 다음과 같다.

```c
arr[i] == *(arr + i)
```

이전의 예제에서 확인할 수 있듯이, 위 식의 값은 true이다. 이로써 포인터 또한 배열처럼 접근할 수 있음을 알 수 있다. 여기서 다시 한번 강조할 수 있다.

> **포인터 = 배열**

다만, **배열 = 포인터는 항상 성립하지만, 포인터 = 배열은 이해할 때 주의하기 바란다.** 배열은 연속된 주소값이라 포인터로 사용할 수 있지만, 포인터로 메모리를 할당하지 않고 선언한 경우는 연속된 주소값이 아닌 단일 주소값이기 때문에 배열처럼 자유자재로 접근할 수 없다.



### 함수에서의 배열과 포인터

 함수의 파라미터로 배열을 넘겨야 할 때가 있다. 이 때 어떻게 넘겨야 할지 헷갈릴 때가 많을 것이다. 결론부터 이야기하자면, **뭘 넘기든 상관 없다. 어짜피 배열 = 포인터이기 때문이다.** 예제로 보자.

```c
void suffleByArray(int arr[], int n) {
    int i = 0, j = 0, temp = 0;
    for (i = 0; i < n; i++) {
        j = rand() % n;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

void suffleByPointer(int *arr, int n) {
    int i = 0, j = 0, temp = 0;
    for (i = 0; i < n; i++) {
        j = rand() % n;
        temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

이 두 함수는 내용은 같지만, 파라미터의 형태가 다르다. 하지만, 함수를 부를 때는 입력은 모두 같다. 다음은 이 함수를 부를 때의 여러가지 호출법이다.

```c
int arr[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

suffleByArray(arr, 10);
suffleByPointer(arr, 10);

suffleByArray(&array[0], 10);
suffleByPointer(&array[0], 10);
```

위 두가지 경우 모두 성립한다. 이를 통해 배열과 포인터는 다름이 아닌 것을 확인할 수 있다.
